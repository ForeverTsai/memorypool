# Memory Pool
--------------------
##前言
在某些内存有限的场景下，应用不断的申请释放(不同大小的)内存，这会造成不少内存碎片,有可能产生更多的缺页异常，向内核申请内存页，如果此时系统空闲内存低于设定的阈值① 时，kswap内核线程会被调用，以回收更多内存，这个过程会有一定的CPU占用率，有可能影响应用的正常工作。
为了减少内存碎片，需要实现内存池，去满足应用不断的申请释放内存块。因此，实现了两种内存池以满足需求：

1. smempool(Single Memory chunk Pool)
2. mmempool(Multiple Memory chunk Pool)

--------------------
>① ：这个阈值指的是watermark[low]。
Linux内核使用watermark的概念来描述内存压力情况，分别有三种标记high、low、min，他们所标记的分别含义为：剩余内存在high以上表示内存剩余较多，目前内存使用压力不大；high-low的范围表示目前剩余内存存在一定压力；low-min表示内存开始有较大使用压力，剩余内存不多了；min是最小的水位标记，当剩余内存达到这个状态时，就说明内存面临很大压力。小于min这部分内存，内核是保留给特定情况下使用的，一般不会分配。内存回收行为就是基于剩余内存的水位标记进行决策的，当系统剩余内存低于watermark[low]的时候，内核的kswapd开始起作用，进行内存回收。直到剩余内存达到watermark[high]的时候停止。如果内存消耗导致剩余内存达到了或超过了watermark[min]时，就会触发直接回收（direct reclaim）。如果直接回收也无法使得内存达到watermark[min]以上，则会触发OOM

--------------------
##1.Single Memory chunk Pool
一种分配释放固定大小内存块的内存池，类似于内核中slab的一种分配方式。



--------------------
##2.Multiple Memory chunk Pool
一种分配释放不同大小内存块的内存池，类似于内核中buddy的一种分配方式，但需要指定内存大小范围，目前最低1K。



